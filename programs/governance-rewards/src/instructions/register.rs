use anchor_lang::prelude::*;
use std::mem::size_of;

use crate::state::{addin::VoterWeightRecord, claim_data::ClaimData, distribution::Distribution};
use crate::{error::GovernanceRewardsError, state::preferences::UserPreferences};

/**
 * Instruction to register for rewards.
 */
#[derive(Accounts)]
pub struct RegisterForRewards<'info> {
    /**
     * Voter Weight Record proving the user is eligible for rewards.
     *
     * The record must be generated by the program specified in the Distribution.
     */
    /// CHECK: Manually deserialized
    #[account(
        owner=distribution.voter_weight_program,
    )]
    voter_weight_record: AccountInfo<'info>,

    /**
     * Distribution to claim on.
     */
    #[account(mut)]
    distribution: Box<Account<'info, Distribution>>,

    /**
     * User claim preferences.
     *
     * This account does not have the be initialized when it is passed to the program.
     * If an empty account is provided, default preferences will be used.
     */
    /// CHECK: Manually deserialized
    #[account(
        seeds = [distribution.realm.as_ref(), b"preferences".as_ref(), registrant.key().as_ref()],
        bump
    )]
    preferences: AccountInfo<'info>,

    /**
     * Claim data account.
     *
     * This account will track information about a user's claims on this distribution.
     */
    #[account(
        init_if_needed,
        space = 8 + size_of::<ClaimData>(),
        payer = payer,
        seeds = [distribution.key().as_ref(), b"claim data".as_ref(), registrant.key().as_ref()],
        bump
    )]
    claim_data: Account<'info, ClaimData>,

    /**
     * User making the claim.
     */
    /// CHECK: Not read
    registrant: AccountInfo<'info>,

    #[account(mut)]
    payer: Signer<'info>,

    system_program: Program<'info, System>,
}

pub fn register_for_rewards(ctx: Context<RegisterForRewards>) -> Result<()> {
    let voter_weight_record = VoterWeightRecord::try_from(&ctx.accounts.voter_weight_record)?;
    let voter_weight_record =
        voter_weight_record.validate(&ctx.accounts.distribution, &ctx.accounts.registrant.key())?;

    require!(
        ctx.accounts.distribution.can_register(),
        GovernanceRewardsError::RegistrationOver
    );

    let weight = voter_weight_record.voter_weight;
    require!(weight > 0, GovernanceRewardsError::NoVoteWeight);

    ctx.accounts.distribution.total_vote_weight = ctx
        .accounts
        .distribution
        .total_vote_weight
        .checked_add(weight)
        .unwrap();

    let preferences = UserPreferences::get_or_default(&ctx.accounts.preferences);

    let (index, preferred_distribution_option) = ctx
        .accounts
        .distribution
        .distribution_options
        .pick_by_mint(preferences.preferred_mint)?;

    preferred_distribution_option.total_vote_weight = preferred_distribution_option
        .total_vote_weight
        .checked_add(weight)
        .unwrap();

    if ctx.accounts.claim_data.has_registered {
        let old_weight = ctx.accounts.claim_data.weight;
        msg!(&format!("{:}", ctx.accounts.claim_data.claim_option));
        msg!("---------------------------------");

        // Remove vote weight from total
        ctx.accounts.distribution.total_vote_weight = ctx
            .accounts
            .distribution
            .total_vote_weight
            .checked_sub(old_weight)
            .unwrap();

        // Remove vote weight from old distribution option
        let old_option = &mut ctx.accounts.distribution.distribution_options
            [ctx.accounts.claim_data.claim_option as usize]
            .unwrap();
        old_option.total_vote_weight = old_option
            .total_vote_weight
            .checked_sub(old_weight)
            .unwrap();
        ctx.accounts.distribution.distribution_options
            [ctx.accounts.claim_data.claim_option as usize] = Some(*old_option);
    }

    ctx.accounts.claim_data.set_inner(ClaimData {
        weight,
        distribution: ctx.accounts.distribution.key(),
        claim_option: index,
        has_claimed: false,
        has_registered: true,
        belongs_to: ctx.accounts.registrant.key(),
    });

    Ok(())
}
